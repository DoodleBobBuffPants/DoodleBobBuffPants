"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[172],{5172:function(e,n,t){t.d(n,{J:function(){return h}});var o=t(9268),a=t(4074);function i(e){let n=Object.assign({h1:"h1",p:"p",code:"code",a:"a",h2:"h2",h3:"h3",pre:"pre",h4:"h4",ul:"ul",li:"li"},(0,a.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{children:"Logging in Java 9+"}),"\n",(0,o.jsxs)(n.p,{children:["Since Java 9, framework-independent logging is available natively through the ",(0,o.jsx)(n.code,{children:"System.LoggerFinder"})," service\nand the ",(0,o.jsx)(n.code,{children:"System.Logger"})," facade. Posts such as ",(0,o.jsx)(n.a,{href:"https://dzone.com/articles/system-logger",children:"Understanding System Logger"}),"\nalready exist which explain how this works with existing logging frameworks such as SLF4J/Log4J2 as well as\ncustom implementations."]}),"\n",(0,o.jsx)(n.p,{children:"This post describes how you might structure logging in a Java library so that it easily hooks into a user's\nenvironment whilst also allowing a custom implementation."}),"\n",(0,o.jsx)(n.h2,{children:"Logging-as-a-Module"}),"\n",(0,o.jsxs)(n.p,{children:["With logging available as a service, custom logging implementations ought to live in a separate ",(0,o.jsx)(n.code,{children:"logging"}),"\nmodule."]}),"\n",(0,o.jsx)(n.p,{children:"Why is this?"}),"\n",(0,o.jsxs)(n.p,{children:["Consumers of your library can then choose between your custom logging implementation, which could be to\n",(0,o.jsx)(n.code,{children:"System.out"})," for console applications, or an existing logging framework such as SLF4J/Log4J2."]}),"\n",(0,o.jsx)(n.h2,{children:"Logging-not-as-a-Module - Multiple Service Providers"}),"\n",(0,o.jsxs)(n.p,{children:["If a custom ",(0,o.jsx)(n.code,{children:"LoggerFinder"})," service is provided in your application module, then users can't easily swap to\nother frameworks."]}),"\n",(0,o.jsx)(n.p,{children:"Why is this?"}),"\n",(0,o.jsxs)(n.p,{children:["A call to ",(0,o.jsx)(n.code,{children:"System.getLogger()"})," only resolves one ",(0,o.jsx)(n.code,{children:"LoggerFinder"})," service, so how does it handle multiple service\nproviders? The answer is that whichever appears first wins. In projects managed by Maven this means, for example,\nthat if a dependency which provides a ",(0,o.jsx)(n.code,{children:"LoggerFinder"})," appears first in the ",(0,o.jsx)(n.code,{children:"dependencies"})," list, it will be used."]}),"\n",(0,o.jsx)(n.h2,{children:"Testability of loggers"}),"\n",(0,o.jsx)(n.p,{children:"With your application code now independent of the underlying logging implementation, it becomes easier to test\ndifferent logging implementations. You simply create a test module that depends on the logging implementation you\nwant to test, and you can begin to verify that it works."}),"\n",(0,o.jsx)(n.h2,{children:"Examples"}),"\n",(0,o.jsx)(n.h3,{children:"Multiple Service Providers"}),"\n",(0,o.jsxs)(n.p,{children:["Let's assume that we're working on a Java project managed by Maven and we have the choice between ",(0,o.jsx)(n.code,{children:"loggerA"})," and\n",(0,o.jsx)(n.code,{children:"loggerB"}),", both which provide a ",(0,o.jsx)(n.code,{children:"LoggerFinder"})," service. Our application also has the following line of code:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"private static final Logger logger = System.getLogger(Main.class.getSimpleName());\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If our ",(0,o.jsx)(n.code,{children:"pom.xml"})," has the following dependency list, then ",(0,o.jsx)(n.code,{children:"Logger"})," will be whatever ",(0,o.jsx)(n.code,{children:"loggerA"})," returns:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<dependencies>\n    <dependency>\n        <groupId>com.loggerA</groupId>\n        <artifactId>loggerA</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.loggerB</groupId>\n        <artifactId>loggerB</artifactId>\n    </dependency>\n</dependencies>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If instead our ",(0,o.jsx)(n.code,{children:"pom.xml"})," has the following dependency list, then ",(0,o.jsx)(n.code,{children:"Logger"})," will be whatever ",(0,o.jsx)(n.code,{children:"loggerB"})," returns:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<dependencies>\n    <dependency>\n        <groupId>com.loggerB</groupId>\n        <artifactId>loggerB</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.loggerA</groupId>\n        <artifactId>loggerA</artifactId>\n    </dependency>\n</dependencies>\n"})}),"\n",(0,o.jsx)(n.h3,{children:"Logging-as-a-Module"}),"\n",(0,o.jsxs)(n.p,{children:["With logging in a separate module, what might an example project look like?\nThe following diagram shows how one might be structured. Note that ",(0,o.jsx)(n.code,{children:"core"})," doesn't directly depend on ",(0,o.jsx)(n.code,{children:"logging"}),"\nas it is up to the user to choose the logging framework they want. In tests however, you would depend on the\nlogging implementation you wish to test or test with."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"parent\n│   pom.xml\n├───core\n│   │   pom.xml\n│   ├───src\n│   └───target\n└───logging\n│   pom.xml\n├───src\n│   └───main\n│       ├───java\n│       │   └───logging\n│       │           CustomLogger.java\n│       │           CustomLoggerFinder.java\n│       └───resources\n│           └───META-INF\n│               └───services\n│                       java.lang.System$LoggerFinder\n└───target\n"})}),"\n",(0,o.jsx)(n.h2,{children:"Conclusion"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"System.LoggerFinder"})," service is a neat way to allow your application to hook into the logging framework\nof the environment it gets used in. However, this means that custom logging implementations need to be developed\nwith this in mind, and providing them as separate modules for consumers to depend on is a very flexible approach\nwith testability of different logging implementations as an added benefit."]}),"\n",(0,o.jsx)(n.h4,{children:"References"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://dzone.com/articles/system-logger",children:"Understanding System Logger"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://docs.oracle.com/javase/9/docs/api/java/lang/System.LoggerFinder.html",children:"System.LoggerFinder"})}),"\n"]})]})}function s(e){let n=Object.assign({h1:"h1",p:"p",em:"em",a:"a",h2:"h2",code:"code",h3:"h3",pre:"pre"},(0,a.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{children:"React + GitHub Pages - 404s with React Router"}),"\n",(0,o.jsxs)(n.p,{children:["Deploying your React app to GitHub pages is a great way to learn about and share them.\nYou can do many things, for example creating mini portfolio sites such as this one!\nIt's a process that is already well documented and you can find an example piece of\ndocumentation in the ",(0,o.jsx)(n.em,{children:"References"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["A common library to use with React apps is React Router which enables client side routing.\nYou can read more about React Router ",(0,o.jsx)(n.a,{href:"https://reactrouter.com/en/main/start/overview",children:"here"}),"\nbut in a nutshell it allows you to render different components at certain URL paths, just\nlike this post. When you run your React app and start navigating to these paths by clicking\non links, buttons etc. you'll see that the path in the URL changes and the component you've\nchosen to render at that path is rendered."]}),"\n",(0,o.jsxs)(n.p,{children:["If, however, you refresh the page or visit a path directly in your browser, you may notice\nthat you get a ",(0,o.jsx)(n.em,{children:"404"})," or a ",(0,o.jsx)(n.em,{children:"blank page"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Note: Depending on how you've configured your development server, you might only get these\n404s or blank pages in production."})}),"\n",(0,o.jsx)(n.h2,{children:"Why do I get 404s or blank pages?"}),"\n",(0,o.jsx)(n.p,{children:"React Router enables client side routing which allows the path in the URL to change without\nrequesting a page for that path from the server. The React app is then responsible for the\ncontent rendered at that path."}),"\n",(0,o.jsx)(n.p,{children:"This only works when you navigate to these paths once the React app is already loaded, which\nonly loads when you visit the homepage of your application. Without it loaded, client side\nrouting won't be enabled and it cannot intercept changes to the path."}),"\n",(0,o.jsx)(n.p,{children:"When you refresh a page or visit a path directly in your browser, the path is loaded without\nclient side routing, so a request is made for a page at that path from the server."}),"\n",(0,o.jsxs)(n.p,{children:["With GitHub Pages, when no page exists for a path, you'll receive either a ",(0,o.jsx)(n.em,{children:"404"})," page or a\n",(0,o.jsx)(n.em,{children:"blank page"}),"."]}),"\n",(0,o.jsx)(n.h2,{children:"Overcoming the 404s and blank pages"}),"\n",(0,o.jsxs)(n.p,{children:["A few solutions are available to us which I came across\non ",(0,o.jsx)(n.a,{href:"https://info340.github.io/client-side-routing.html#react-router-and-hosting",children:"this"}),"\npage about client side routing."]}),"\n",(0,o.jsxs)(n.p,{children:["One solution is to deploy our React app to a system that allows us to serve our ",(0,o.jsx)(n.code,{children:"index.html"}),",\nour homepage, for any path. This would be the cleanest option as it doesn't require making changes\nto our React app, however we can't then say we've successfully deployed to GitHub Pages!"]}),"\n",(0,o.jsxs)(n.p,{children:["Another solution is to use a ",(0,o.jsx)(n.code,{children:"HashRouter"})," instead of a ",(0,o.jsx)(n.code,{children:"BrowserRouter"})," from React Router. With a\n",(0,o.jsx)(n.code,{children:"HashRouter"})," our homepage is requested for every path which solves our problem. The downside\nhowever is that the ",(0,o.jsx)(n.code,{children:"HashRouter"})," modifies all paths by injecting a ",(0,o.jsx)(n.code,{children:"#"})," into the beginning."]}),"\n",(0,o.jsx)(n.p,{children:"My preferred solution is to set up redirects in a custom 404 page on GitHub Pages and in our\nhomepage. This doesn't modify our paths, nor does it require changing where we deploy our React\napp, and it is a purely JavaScript-based solution too."}),"\n",(0,o.jsx)(n.h3,{children:"Redirects in a custom 404 page"}),"\n",(0,o.jsx)(n.p,{children:"How this works is when we get a 404 or a blank page, GitHub Pages can be configured to use a custom\n404 page. In this custom 404 page we will add a script element that redirects to our homepage, and the\npath that failed to load will be added as a query parameter to the redirect URL. We then also need to\nadd a script element to our homepage which reads this query parameter and sets the current path to the\nvalue we read."}),"\n",(0,o.jsx)(n.p,{children:"That's all there is to it! Now let's take a look at how to add the custom 404 page and the script elements\nwe need."}),"\n",(0,o.jsxs)(n.p,{children:["A custom 404 page can be added to GitHub pages very easily - we just add a ",(0,o.jsx)(n.code,{children:"404.html"})," to our output folder,\nwhich is where our ",(0,o.jsx)(n.code,{children:"index.html"})," homepage is located, and we are done!"]}),"\n",(0,o.jsx)(n.p,{children:"Next we need a script element in this custom 404 page that redirects to the homepage but includes the current\npath as a query parameter. An example script element that achieves this is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:'<script type="text/javascript">\n  const l = window.location;\n  const pathname = l.pathname.startsWith("/") ? l.pathname.substring(1) : l.pathname;\n  window.location = `${l.protocol}//${l.host}/?${pathname}`;\n</script>\n'})}),"\n",(0,o.jsx)(n.p,{children:"Lastly we need a script element in our homepage that checks if the URL has this query parameter, and navigates\nto it as a path if it exists. An example script element that achieves this is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:'<script type="text/javascript">\n  const l = window.location;\n  if (l.search && `${l.protocol}//${l.host}/${l.search}` === l.href) {\n    const path = l.search.substring(1);\n    window.history.replaceState(null, null, `${l.protocol}//${l.host}/${path}`);\n  }\n</script>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In our homepage we navigate using ",(0,o.jsx)(n.code,{children:"history.replaceState()"})," which modifies the current URL while staying on\nthe currently loaded page, the homepage, which has client side routing enabled. Our path will now load and\nrender as desired!"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.em,{children:["Note: These scripts assume you don't make use of query parameters in your React app. If you do you can modify\nthem to use a key e.g. ",(0,o.jsx)(n.code,{children:"?redirect=${pathname}"})," instead of ",(0,o.jsx)(n.code,{children:"?${pathname}"}),"."]})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.em,{children:["Note: The script element in the homepage must appear before the element that your React app renders to, most\ncommonly the ",(0,o.jsx)(n.code,{children:"<div>"})," given an id of ",(0,o.jsx)(n.code,{children:"root"}),"."]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"## Conclusion\n\nBeing able to deploy React apps to GitHub Pages is a great facility available to us, however\nwe may receive a _404_ page or a _blank page_ which can ruin the experience. There are solutions\navailable to us, of which my preferred is to set up redirects in a custom 404 page on GitHub Pages\nwhich makes paths in our React app both refreshable and shareable, thus restoring the experience.\n\nThe source code for this website, which makes use of the solution described in this post, can be\nfound [here](https://github.com/DoodleBobBuffPants/DoodleBobBuffPants.github.io).\n\n#### References\n\n- [Example documentation for deploying a React app to GitHub Pages](https://github.com/gitname/react-gh-pages#deploying-a-react-app-to-github-pages)\n- [React Router overview](https://reactrouter.com/en/main/start/overview)\n- [React Router and Hosting](https://info340.github.io/client-side-routing.html#react-router-and-hosting)\n"})})]})}let r=[{filename:"2022-05-02-Logging-in-Java-9+.md",component:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,o.jsx)(n,Object.assign({},e,{children:(0,o.jsx)(i,e)})):i(e)}},{filename:"2022-10-05-React-+-GitHub-Pages_404s-with-React-Router.md",component:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,o.jsx)(n,Object.assign({},e,{children:(0,o.jsx)(s,e)})):s(e)}}],h=()=>r.map(e=>{let n=e.filename.match("(\\d+)-(\\d+)-(\\d+)-(.+).md");return{path:"/posts/".concat(n[1],"/").concat(n[2],"/").concat(n[3],"/").concat(n[4]),title:n[4],component:e.component}})}}]);